C      ALGORITHM 748, COLLECTED ALGORITHMS FROM ACM.
C      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,
C      VOL. 21, NO. 3, September, 1995, P.  327-344.
C
C This file contains 5 files separated by lines of the form
C         C*** filename
C
C The filenames in this file are:
C
C driver.f             enclofx.f            exdrive.f           
C testdata             testout                                  
C
C*** driver.f
C        TEST PROBLEM SET ATTACHED TO THE ALGORITHM "ENCLOFX"
C        WITH THE COMPANION PAPER "ENCLOSING ZEROS OF CONTINUOUS
C        FUNCTIONS" BY
C        G.E.ALEFELD, F.A.POTRA, AND YIXUN SHI.
C
C        THE FOLLOWING RUNS THE SET OF TEST PROBLEMS LISTED IN THE
C        COMPANION PAPER. THE RESULT OF THE TEST RUN IS ALSO LISTED
C        IN THAT PAPER.
C
C ******************************************************************
         INTEGER NPROB,NEPS,ISIGN
	 INTEGER N
         DOUBLE PRECISION A,B,EPS,ROOT
         EXTERNAL ISIGN
	 COMMON /USER/ N
C THIS PROGRAM CALCULATES A ROOT OF A CONTINUOUS FUNCTION F(X)         
C IN AN INTERVAL I=[A, B] PROVIDED THAT F(A)F(B)<0. THE FUNCTION F(X)
C AND THE INITIAL INTERVAL [A, B] ARE TO BE SUPPLIED BY THE USER IN 
C THE SUBROUTINES "FUNC" AND "INIT". THE OUTPUT "ROOT" EITHER SATISFIES
C THAT F(ROOT)=0 OR IS AN APPROXIMATE SOLUTION OF THE EQUATION F(X)=0
C SUCH THAT "ROOT" IS INCLUDED IN AN INTERVAL [AC, BC] WITH
C      F(AC)F(BC)<0,
C AND
C      BC-AC <= TOL = 2*TOLE(AC,BC).
C PRECISION CHOSEN AS THE RELATIVE MACHINE PRECISION,
C AND "UC" IS EQUAL TO EITHER "AC" OR "BC" WITH THE CONDITION
C      |F(UC)| = MIN{ |F(AC)|, |F(BC)| }.
C
C INPUT OF THE PROGRAM:
C  NPROB -- INTEGER. POSITIVE INTEGER STANDING FOR "NUMBER OF PROBLEM",
C           INDICATING THE PROBLEM TO BE SOLVED.
C  N     -- PROBLEM DEPENDENT PARAMETER
C OUTPUT OF THE PROGRAM:
C  ROOT  -- DOUBLE PRECISION. EXACT OR APPROXIMATE SOLUTION OF THE
C           EQUATION F(X)=0.

10       READ(*,*,END=20) NPROB, N
C
C USE MACHINE PRECISION
C
	 CALL RMP(EPS)
	 NEPS = 1000
C
C CALL SUBROUTINE "INIT" TO GET THE INITIAL INTERVAL.
C 
         CALL INIT(NPROB, A, B)
C
C CALL SUBROUTINE "RROOT" TO HAVE THE PROBLEM SOLVED.
C
         CALL RROOT(NPROB,NEPS,EPS,A,B,ROOT)
         CONTINUE
C
C PRINT OUT THE RESULT ON THE SCREEN.
C
         PRINT*, 'PROBLEM NUMBER ', NPROB, 
     +           ' WITH PROBLEM PARAMETER ', N
         PRINT*, 'COMPUTED ROOT =', ROOT
	 PRINT*, ' '
	 GOTO 10
20       STOP
         END

         SUBROUTINE INIT(NPROB, A, B)
         INTEGER NPROB
         DOUBLE PRECISION A,B,PI

         PI=3.1416D0
         GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,
     *    22,23,24,25,26,27,28), NPROB

1        A=PI/2.0D0
         B=PI
         RETURN

2        A=1.0D0+1.0D-9
         B=(2.0D0)*(2.0D0)-1.0D-9
         RETURN

3        A=(2.0D0)*(2.0D0)+1.0D-9
         B=(3.0D0)*(3.0D0)-1.0D-9
         RETURN

4        A=(3.0D0)*(3.0D0)+1.0D-9
         B=(4.0D0)*(4.0D0)-1.0D-9
         RETURN

5        A=(4.0D0)*(4.0D0)+1.0D-9
         B=(5.0D0)*(5.0D0)-1.0D-9
         RETURN

6        A=(5.0D0)*(5.0D0)+1.0D-9
         B=(6.0D0)*(6.0D0)-1.0D-9
         RETURN

7        A=(6.0D0)*(6.0D0)+1.0D-9
         B=(7.0D0)*(7.0D0)-1.0D-9
         RETURN

8        A=(7.0D0)*(7.0D0)+1.0D-9
         B=(8.0D0)*(8.0D0)-1.0D-9
         RETURN

9        A=(8.0D0)*(8.0D0)+1.0D-9
         B=(9.0D0)*(9.0D0)-1.0D-9
         RETURN

10       A=(9.0D0)*(9.0D0)+1.0D-9
         B=(10.0D0)*(10.0D0)-1.0D-9
         RETURN

11       A=(10.0D0)*(10.0D0)+1.0D-9
         B=(11.0D0)*(11.0D0)-1.0D-9
         RETURN

12       CONTINUE

13       CONTINUE

14       A=-9.0D0
         B=31.0D0
         RETURN

15       CONTINUE

16       A=0.0D0
         B=5.0D0
         RETURN

17      A=-0.95D0
        B=4.05D0
        RETURN

18       A=0.0D0
         B=1.5D0
         RETURN

19       CONTINUE

20       CONTINUE

21       CONTINUE

22       CONTINUE

23       A=0.0D0
         B=1.0D0
         RETURN

24       A=1.0D-2
         B=1.0D0
         RETURN

25       A=1.0D0
         B=100.0D0
         RETURN

26       A=-1.0D0
         B=4.0D0
         RETURN

27       A=-10000
         B=PI/2.0D0
         RETURN

28       A=-10000
         B=1.0D-4
         RETURN

         END

C        *****************

         SUBROUTINE FUNC(NPROB, X, FX)
         INTEGER NPROB, N,I
         DOUBLE PRECISION X, FX, DN, DFLOAT, DI
	 COMMON /USER/ N

C         N --- AN INTEGER USED IN THE FUNCTION. 
C

         DN=DFLOAT(N)
         
         GOTO (10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,
     *         160,170,180,190,200,210,220,230,240,250,260,
     *         270,280), NPROB

10       FX=DSIN(X)-X/2.0D0
         RETURN

20       CONTINUE
30       CONTINUE
40       CONTINUE
50       CONTINUE
60       CONTINUE
70       CONTINUE
80       CONTINUE
90       CONTINUE
100      CONTINUE
110      CONTINUE
         FX=0.0D0
         DO 115 I=1,20
           DI=DFLOAT(I)
           FX=FX+((2.0D0*DI-5.0D0)**2)/(X-DI*DI)**3
115      CONTINUE
         FX=-2.0D0*FX
         RETURN
120      FX=-40.0D0*X*DEXP(-1.0D0*X)
         RETURN

130      FX=-100.0D0*X*DEXP(-2.0D0*X)
         RETURN

140      FX=-200.0D0*X*DEXP(-3.0D0*X)
         RETURN

150      FX=X**N-0.2D0
         RETURN

160      CONTINUE
170      FX=X**N-1.0D0
         RETURN

180      FX=DSIN(X)-0.5D0
         RETURN

190      FX=2.0D0*X*DEXP(-DN)-2.0D0*DEXP(-DN*X)+1.0D0
         RETURN

200      FX=(1.0D0+(1.0D0-DN)**2)*X - (1.0D0-DN*X)**2
         RETURN

210      FX=X**2-(1.0D0-X)**N
         RETURN

220      FX=(1.0D0+(1.0D0-DN)**4)*X - (1.0D0-DN*X)**4
         RETURN

230      FX=(X-1.0D0)*DEXP(-DN*X)+X**N
         RETURN

240      FX=(DN*X-1.0D0)/((DN-1.0D0)*X)
         RETURN

250      FX=X**(1.0D0/DN)-DN**(1.0D0/DN)
         RETURN

260      CONTINUE
         IF(X .EQ. 0.0D0)THEN
           FX=0.0D0
         ELSE
           FX=X/DEXP(1.0D0/(X*X))
         ENDIF
         RETURN

270      CONTINUE
         IF(X .GE. 0.0D0)THEN
           FX=(X/1.5D0 + DSIN(X) -1.0D0)*DN/20.0D0
         ELSE
           FX=(-1.0D0*DN)/20.0D0
         ENDIF
         RETURN

280      CONTINUE
         IF(X .GE. (1.0D-3)*2.0D0/(DN+1.0D0)) THEN
           FX=DEXP(1.0D0)-1.859D0
         ELSEIF (X .GE. 0.0D0)THEN
            FX=DEXP((DN+1.0D0)*0.5D0*X*1.0D3)-1.859D0
         ELSE
           FX=-0.859D0
         ENDIF
         RETURN

         END
C*** enclofx.f
         SUBROUTINE RROOT(NPROB,NEPS,EPS,A,B,ROOT)
C FINDS EITHER AN EXACT SOLUTION OR AN APPROXIMATE SOLUTION OF THE
C EQUATION F(X)=0 IN THE INTERVAL [A,B]. AT THE BEGINING OF EACH
C ITERATION, THE CURRENT ENCLOSING INTERVAL IS RECORDED AS [A0,B0].
C THE FIRST ITERATION IS SIMPLY A SECANT STEP. STARTING WITH THE
C SECOND ITERATION, THREE STEPS ARE TAKEN IN EACH ITERATION. FIRST
C TWO STEPS ARE EITHER QUADRATIC INTERPOLATION OR CUBIC INVERSE
C INTERPOLATION. THE THIRD STEP IS A DOUBLE-SIZE SECANT STEP. IF THE
C DIAMETER OF THE ENCLOSING INTERVAL OBTAINED AFTER THOSE THREE STEPS
C IS LARGER THAN 0.5*(B0-A0), THEN AN ADDITIONAL BISECTION STEP WILL
C BE TAKEN.
C  NPROB -- INTEGER. INDICATING THE PROBLEM TO BE SOLVED;
C  NEPS  -- INTEGER. USED TO DETERMINE THE TERMINATION CRITERION;
C  EPS   -- DOUBLE PRECISION. USED IN THE TERMINATION CRITERION;
C  A,B   -- DOUBLE PRECISION. INPUT AS THE INITIAL INTERVAL AND 
C           OUTPUT AS THE ENCLOSING INTERVAL AT THE TERMINATION;
C  ROOT  -- DOUBLE PRECISION. OUTPUT SOLUTION OF THE EQUATION.
         INTEGER NPROB,ITNUM,ISIGN,NEPS
         DOUBLE PRECISION A,B,FA,FB,C,U,FU,MU,A0,B0,TOL,D,FD
         DOUBLE PRECISION PROF,E,FE,EPS,ROOT
         EXTERNAL ISIGN
         PARAMETER (MU=0.5D0)
C
C INITIALIZATION. SET THE NUMBER OF ITERATION AS 0. CALL SUBROUTINE
C "FUNC" TO OBTAIN THE INITIAL FUNCTION VALUES F(A) AND F(B). SET
C DUMB VALUES FOR THE VARIABLES "E" AND "FE".
C
         ITNUM=0
         CALL FUNC(NPROB,A,FA)
         CALL FUNC(NPROB,B,FB)
         E=1.0D5
         FE=1.0D5
C
C ITERATION STARTS. THE ENCLOSING INTERVAL BEFORE EXECUTING THE
C ITERATION IS RECORDED AS [A0, B0].
C
 10      A0=A
         B0=B
C
C UPDATES THE NUMBER OF ITERATION.
C
         ITNUM=ITNUM+1
C
C CALCULATES THE TERMINATION CRITERION. STOPS THE PROCEDURE IF THE
C CRITERION IS SATISFIED.
C
         IF(DABS(FB) .LE. DABS(FA)) THEN
          CALL TOLE(B,TOL,NEPS,EPS)
         ELSE
          CALL TOLE(A,TOL,NEPS,EPS)
         ENDIF
         IF((B-A).LE.TOL)GOTO 400
C
C FOR THE FIRST ITERATION, SECANT STEP IS TAKEN.
C
         IF(ITNUM .EQ. 1)THEN
          C=A-(FA/(FB-FA))*(B-A)
C
C CALL SUBROUTINE "BRACKT" TO GET A SHRINKED ENCLOSING INTERVAL AS
C WELL AS TO UPDATE THE TERMINATION CRITERION. STOP THE PROCEDURE
C IF THE CRITERION IS SATISFIED OR THE EXACT SOLUTION IS OBTAINED.
C
          CALL BRACKT(NPROB,A,B,C,FA,FB,TOL,NEPS,EPS,D,FD)
          IF((FA.EQ.0.0D0).OR.((B-A).LE.TOL))GOTO 400
          GOTO 10
         ENDIF
C
C STARTING WITH THE SECOND ITERATION, IN THE FIRST TWO STEPS, EITHER
C QUADRATIC INTERPOLATION IS USED BY CALLING THE SUBROUTINE "NEWQUA"
C OR THE CUBIC INVERSE INTERPOLATION IS USED BY CALLING THE SUBROUTINE
C "PZERO". IN THE FOLLOWING, IF "PROF" IS NOT EQUAL TO 0, THEN THE
C FOUR FUNCTION VALUES "FA", "FB", "FD", AND "FE" ARE DISTINCT, AND
C HENCE "PZERO" WILL BE CALLED.
C
         PROF=(FA-FB)*(FA-FD)*(FA-FE)*(FB-FD)*(FB-FE)*(FD-FE)          
         IF((ITNUM .EQ. 2) .OR. (PROF .EQ. 0.0D0)) THEN
          CALL NEWQUA(A,B,D,FA,FB,FD,C,2)
         ELSE
          CALL PZERO(A,B,D,E,FA,FB,FD,FE,C)
          IF((C-A)*(C-B) .GE. 0.0D0)THEN
           CALL NEWQUA(A,B,D,FA,FB,FD,C,2)
          ENDIF
         ENDIF
         E=D
         FE=FD
C
C CALL SUBROUTINE "BRACKT" TO GET A SHRINKED ENCLOSING INTERVAL AS
C WELL AS TO UPDATE THE TERMINATION CRITERION. STOP THE PROCEDURE
C IF THE CRITERION IS SATISFIED OR THE EXACT SOLUTION IS OBTAINED.
C
         CALL BRACKT(NPROB,A,B,C,FA,FB,TOL,NEPS,EPS,D,FD)
         IF((FA.EQ.0.0D0).OR.((B-A).LE.TOL))GOTO 400
         PROF=(FA-FB)*(FA-FD)*(FA-FE)*(FB-FD)*(FB-FE)*(FD-FE)          
         IF(PROF .EQ. 0.0D0) THEN
          CALL NEWQUA(A,B,D,FA,FB,FD,C,3)
         ELSE
          CALL PZERO(A,B,D,E,FA,FB,FD,FE,C)
          IF((C-A)*(C-B) .GE. 0.0D0)THEN
           CALL NEWQUA(A,B,D,FA,FB,FD,C,3)
          ENDIF
         ENDIF
C
C CALL SUBROUTINE "BRACKT" TO GET A SHRINKED ENCLOSING INTERVAL AS
C WELL AS TO UPDATE THE TERMINATION CRITERION. STOP THE PROCEDURE
C IF THE CRITERION IS SATISFIED OR THE EXACT SOLUTION IS OBTAINED.
C
         CALL BRACKT(NPROB,A,B,C,FA,FB,TOL,NEPS,EPS,D,FD)
         IF((FA.EQ.0.0D0).OR.((B-A).LE.TOL))GOTO 400
         E=D
         FE=FD
C
C TAKES THE DOUBLE-SIZE SECANT STEP.
C
         IF (DABS(FA) .LT. DABS(FB))THEN
          U=A
          FU=FA
         ELSE
          U=B
          FU=FB
         ENDIF
         C=U-2.0D0*(FU/(FB-FA))*(B-A)
         IF(DABS(C-U) .GT. (0.5D0*(B-A)))THEN
          C=A+0.5D0*(B-A)
         ENDIF
C
C CALL SUBROUTINE "BRACKT" TO GET A SHRINKED ENCLOSING INTERVAL AS
C WELL AS TO UPDATE THE TERMINATION CRITERION. STOP THE PROCEDURE
C IF THE CRITERION IS SATISFIED OR THE EXACT SOLUTION IS OBTAINED.
C
         CALL BRACKT(NPROB,A,B,C,FA,FB,TOL,NEPS,EPS,D,FD)
         IF((FA.EQ.0.0D0).OR.((B-A).LE.TOL))GOTO 400
C
C DETERMINES WHETHER AN ADDITIONAL BISECTION STEP IS NEEDED. AND TAKES
C IT IF NECESSARY.
C
         IF((B-A) .LT. (MU*(B0-A0)))THEN
           GOTO 10
         ENDIF
         E=D
         FE=FD
C
C CALL SUBROUTINE "BRACKT" TO GET A SHRINKED ENCLOSING INTERVAL AS
C WELL AS TO UPDATE THE TERMINATION CRITERION. STOP THE PROCEDURE
C IF THE CRITERION IS SATISFIED OR THE EXACT SOLUTION IS OBTAINED.
C
         CALL BRACKT(NPROB,A,B,A+0.5D0*(B-A),FA,FB,TOL,NEPS,EPS,D,FD)         
         IF((FA .EQ. 0.0D0).OR.((B-A).LE.TOL))GOTO 400
         GOTO 10
C
C TERMINATES THE PROCEDURE AND RETURN THE "ROOT".
C
 400     CONTINUE
         ROOT=A
         RETURN
         END

         SUBROUTINE BRACKT(NPROB,A,B,C,FA,FB,TOL,NEPS,EPS,D,FD)
C GIVEN CURRENT ENCLOSING INTERVAL [A,B] AND A NUMBER C IN (A,B), IF
C F(C)=0 THEN SETS THE OUTPUT A=C. OTHERWISE DETERMINES THE NEW
C ENCLOSING INTERVAL: [A,B]=[A,C] OR [A,B]=[C,B]. ALSO UPDATES THE
C TERMINATION CRITERION CORRESPONDING TO THE NEW ENCLOSING INTERVAL.
C  NPROB   -- INTEGER. INDICATING THE PROBLEM TO BE SOLVED;
C  A,B     -- DOUBLE PRECISION. [A,B] IS INPUT AS THE CURRENT 
C             ENCLOSING INTERVAL AND OUTPUT AS THE SHRINKED NEW 
C             ENCLOSING INTERVAL;
C  C       -- DOUBLE PRECISION. USED TO DETERMINE THE NEW ENCLOSING
C             INTERVAL;
C  D       -- DOUBLE PRECISION. OUTPUT: IF THE NEW ENCLOSING INTERVAL
C             IS [A,C] THEN D=B, OTHERWISE D=A;
C  FA,FB,FD-- DOUBLE PRECISION. FA=F(A), FB=F(B), AND FD=F(D);
C  TOL     -- DOUBLE PRECISION. INPUT AS THE CURRENT TERMINATION 
C             CRITERION AND OUTPUT AS THE UPDATED TERMINATION 
C             CRITERION ACCORDING TO THE NEW ENCLOSING INTERVAL;
C  NEPS    -- INTEGER. USED TO DETERMINE THE TERMINATION CRITERION;
C  EPS     -- DOUBLE PRECISION. USED IN THE TERMINATION CRITERION.
         INTEGER NPROB,ISIGN,NEPS
         DOUBLE PRECISION A,B,C,FA,FB,FC,D,FD,TOL,EPS
         EXTERNAL ISIGN
C
C ADJUST C IF (B-A) IS VERY SMALL OR IF C IS VERY CLOSE TO A OR B.
C
         TOL=0.7D0*TOL
         IF((B-A) .LE. 2.0D0*TOL)THEN
          C=A+0.5D0*(B-A)
         ELSEIF(C .LE. A+TOL)THEN
          C=A+TOL
         ELSE
          IF(C .GE. B-TOL)THEN
           C=B-TOL
          ENDIF
         ENDIF
C
C CALL SUBROUTINE "FUNC" TO OBTAIN F(C)
C
         CALL FUNC(NPROB, C, FC)
C
C IF F(C)=0, THEN SET A=C AND RETURN. THIS WILL TERMINATE THE 
C PROCEDURE IN SUBROUTINE "RROOT" AND GIVE THE EXACT SOLUTION OF 
C THE EQUATION F(X)=0.
C
         IF(FC .EQ. 0.0D0)THEN
          A=C
          FA=0.0D0
          D=0.0D0
          FD=0.0D0
          RETURN
         ENDIF
C
C IF F(C) IS NOT ZERO, THEN DETERMINE THE NEW ENCLOSING INTERVAL.
C
         IF((ISIGN(FA)*ISIGN(FC)) .LT. 0)THEN
          D=B
          FD=FB
          B=C
          FB=FC
         ELSE
          D=A
          FD=FA
          A=C
          FA=FC
         ENDIF
C
C UPDATE THE TERMINATION CRITERION ACCORDING TO THE NEW ENCLOSING
C INTERVAL.
C
         IF(DABS(FB) .LE. DABS(FA)) THEN
          CALL TOLE(B,TOL,NEPS,EPS)
         ELSE
          CALL TOLE(A,TOL,NEPS,EPS)
         ENDIF
C
C END OF THE SUBROUTINE.
C
         RETURN
         END

         INTEGER FUNCTION ISIGN(X)
C INDICATES THE SIGN OF THE VARIABLE "X".
C  X     -- DOUBLE PRECISION.
C  ISIGN -- INTEGER.
         DOUBLE PRECISION X
         IF(X .GT. 0.0D0)THEN
          ISIGN=1
         ELSEIF(X .EQ. 0.0D0)THEN
          ISIGN=0
         ELSE
          ISIGN=-1
         ENDIF
         RETURN
         END

         SUBROUTINE TOLE(B,TOL,NEPS,EPS)
C DETERMINES THE TERMINATION CRITERION.
C  B    -- DOUBLE PRECISION.
C  NEPS -- INTEGER.
C  EPS  -- DOUBLE PRECISION.
C  TOL  -- DOUBLE PRECISION. OUTPUT AS THE TERMINATION CRITERION.
C           TOL =2*(2*EPS*|B| + 10D-{NEPS}),  IF NEPS IS NOT 1000;
C    AND    TOL =2*(2*EPS*|B|),               IF NEPS = 1000. 
         INTEGER NEPS,I
         DOUBLE PRECISION B,TOL,EPS
         IF(NEPS .EQ. 1000)THEN
          TOL=0.0D0
         ELSE
          TOL=1.0D0
          DO 10 I=1,NEPS
           TOL=TOL/10.0D0
 10       CONTINUE
         ENDIF
         TOL=TOL+2.0D0*DABS(B)*EPS
         TOL=2.0D0*TOL
         RETURN
         END

         SUBROUTINE NEWQUA(A,B,D,FA,FB,FD,C,K)
C USES K NEWTON STEPS TO APPROXIMATE THE ZERO IN (A,B) OF THE
C QUADRATIC POLYNOMIAL INTERPOLATING F(X) AT A, B, AND D. SAFEGUARD
C IS USED TO AVOID OVERFLOW.
C  A,B,D,FA,FB,FD -- DOUBLE PRECISION. D LIES OUTSIDE THE INTERVAL
C                    [A,B]. FA=F(A), FB=F(B), AND FD=F(D). F(A)F(B)<0.        
C  C              -- DOUBLE PRECISION. OUTPUT AS THE APPROXIMATE ZERO
C                    IN (A,B) OF THE QUADRATIC POLYNOMIAL.
C  K              -- INTEGER. INPUT INDICATING THE NUMBER OF NEWTON 
C                    STEPS TO TAKE.
         INTEGER K,IERROR,ISIGN,I
         DOUBLE PRECISION A,B,D,FA,FB,FD,C,A0,A1,A2,PC,PDC
         EXTERNAL ISIGN
C
C INITIALIZATION. FIND THE COEFFICIENTS OF THE QUADRATIC POLYNOMIAL.
C
         IERROR=0
         A0=FA
         A1=(FB-FA)/(B-A)
         A2=((FD-FB)/(D-B)-A1)/(D-A)
C
C SAFEGUARD TO AVOID OVERFLOW.
C
  10     IF((A2 .EQ. 0.0D0).OR.(IERROR .EQ. 1))THEN
          C=A-A0/A1
          RETURN
         ENDIF
C
C DETERMINE THE STARTING POINT OF NEWTON STEPS.
C
         IF(ISIGN(A2)*ISIGN(FA) .GT. 0)THEN
          C=A
         ELSE
          C=B
         ENDIF
C
C START THE SAFEGUARDED NEWTON STEPS.
C
         DO 20 I=1,K
         IF(IERROR .EQ. 0)THEN
          PC=A0+(A1+A2*(C-B))*(C-A)
          PDC=A1+A2*((2.0D0*C)-(A+B))
          IF(PDC .EQ. 0.0D0)THEN
           IERROR=1
          ELSE
           C=C-PC/PDC
          ENDIF
         ENDIF
  20     CONTINUE
         IF(IERROR .EQ. 1)GOTO 10
         RETURN
         END

         SUBROUTINE PZERO(A,B,D,E,FA,FB,FD,FE,C)
C USES CUBIC INVERSE INTERPOLATION OF F(X) AT A, B, D, AND E TO
C GET AN APPROXIMATE ROOT OF F(X). THIS PROCEDURE IS A SLIGHT
C MODIFICATION OF AITKEN-NEVILLE ALGORITHM FOR INTERPOLATION
C DESCRIBED BY STOER AND BULIRSCH IN "INTRO. TO NUMERICAL ANALYSIS"
C SPRINGER-VERLAG. NEW YORK (1980).
C  A,B,D,E,FA,FB,FD,FE -- DOUBLE PRECISION. D AND E LIE OUTSIDE
C                         THE INTERVAL [A,B]. FA=F(A), FB=F(B),
C                         FD=F(D), AND FE=F(E).
C  C                   -- DOUBLE PRECISION. OUTPUT OF THE SUBROUTINE.        
         DOUBLE PRECISION A,B,D,E,FA,FB,FD,FE,C,Q11,Q21,Q31,D21,D31         
         DOUBLE PRECISION Q22,Q32,D32,Q33
C
         Q11=(D-E)*FD/(FE-FD)
         Q21=(B-D)*FB/(FD-FB)
         Q31=(A-B)*FA/(FB-FA)
         D21=(B-D)*FD/(FD-FB)
         D31=(A-B)*FB/(FB-FA)
         Q22=(D21-Q11)*FB/(FE-FB)
         Q32=(D31-Q21)*FA/(FD-FA)
         D32=(D31-Q21)*FD/(FD-FA)
         Q33=(D32-Q22)*FA/(FE-FA)
C
C CALCULATE THE OUTPUT C.
C
         C=Q31+Q32+Q33
         C=A+C
         RETURN
         END

         SUBROUTINE RMP(REL)
C CALCULATES THE RELATIVE MACHINE PRECISION (RMP).
C  REL -- DOUBLE PRECISION. OUTPUT OF RMP.
C
         DOUBLE PRECISION REL,BETA,A,B
         BETA=2.0D0
         A=1.0D0
 10      B=1.0D0+A
         IF(B .GT. 1.0D0)THEN
          A=A/BETA
          GOTO 10
         ENDIF
         REL=A*BETA
         RETURN
         END
