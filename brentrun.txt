ian@ian:~$ cd brent
ian@ian:~/brent$ wget https://people.sc.fsu.edu/~jburkardt/f_src/brent_test/brent_test.f90
--2020-12-12 14:06:11--  https://people.sc.fsu.edu/~jburkardt/f_src/brent_test/brent_test.f90
Resolving people.sc.fsu.edu (people.sc.fsu.edu)... 144.174.16.102
Connecting to people.sc.fsu.edu (people.sc.fsu.edu)|144.174.16.102|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 27002 (26K) [text/plain]
Saving to: 'brent_test.f90’

brent_test.f90      100%[===================>]  26.37K   109KB/s    in 0.2s    

2020-12-12 14:06:12 (109 KB/s) - 'brent_test.f90’ saved [27002/27002]

ian@ian:~/brent$ gfortran brent_test.f90
/tmp/ccBvjqON.o: In function `test_glomin_one_':
brent_test.f90:(.text+0x7e9): undefined reference to `glomin_'
/tmp/ccBvjqON.o: In function `test_local_min_rc_one_':
brent_test.f90:(.text+0x1673): undefined reference to `local_min_rc_'
/tmp/ccBvjqON.o: In function `test_local_min_one_':
brent_test.f90:(.text+0x1d5c): undefined reference to `local_min_'
/tmp/ccBvjqON.o: In function `test_zero_rc_one_':
brent_test.f90:(.text+0x294e): undefined reference to `zero_rc_'
/tmp/ccBvjqON.o: In function `test_zero_one_':
brent_test.f90:(.text+0x2fae): undefined reference to `zero_'
/tmp/ccBvjqON.o: In function `MAIN__':
brent_test.f90:(.text+0x34b7): undefined reference to `timestamp_'
brent_test.f90:(.text+0x38c2): undefined reference to `timestamp_'
collect2: error: ld returned 1 exit status
ian@ian:~/brent$ ls
brent.f90  brent_test.f90
ian@ian:~/brent$ f90 brent.f90 -c brent_test.f90 -c

Command 'f90' not found, did you mean:

  command 'f95' from deb gfortran

Try: sudo apt install <deb name>

ian@ian:~/brent$ gfortran brent.f90 -c brent_test.f90 -c
ian@ian:~/brent$ ls
brent.f90  brent.o  brent_test.f90  brent_test.o
ian@ian:~/brent$ gfortran -o brentrun brent.o brent_test.o
ian@ian:~/brent$ ./brentrun
12 December 2020   2:14:27.227 PM
 
BRENT_TEST
  FORTRAN90 version.
  Test the BRENT library.
 
TEST_ZERO_ALL
  Test the Brent ZERO routine, which seeks
  a root of a function F(X)
  in an interval [A,B].
 
f_01(x) = sin ( x ) - x / 2
 
      A                 Z             B
    F(A)              F(Z)          F(B)
 
      1.00000000      1.89549427      2.00000000
    0.341471         0.00000       -0.907026E-01
 
f_02(x) = 2 * x - exp ( - x )
 
      A                 Z             B
    F(A)              F(Z)          F(B)
 
      0.00000000      0.35173371      1.00000000
    -1.00000         0.00000         1.63212    
 
f_03(x) = x * exp ( - x )
 
      A                 Z             B
    F(A)              F(Z)          F(B)
 
     -1.00000000      0.00000000      0.50000000
    -2.71828        0.267518E-23    0.303265    
 
f_04(x) = exp ( x ) - 1 / ( 100 * x * x )
 
      A                 Z             B
    F(A)              F(Z)          F(B)
 
      0.00010000      0.09534462     20.00000000
    -999999.       -0.222045E-15    0.485165E+09
 
f_05(x) = (x+3) * (x-1) * (x-1)
 
      A                 Z             B
    F(A)              F(Z)          F(B)
 
     -5.00000000     -3.00000000      2.00000000
    -72.0000         0.00000         5.00000    
 
TEST_ZERO_RC_ALL
  Test the reverse communication version of the Brent ZERO
  routine, which seeks a root of a function F(X)
  in an interval [A,B].
 
f_01(x) = sin ( x ) - x / 2
 
    STATUS      X               F(X)
 
         1   1.0000000      0.34147098    
         2   2.0000000      -.90702573E-01
         3   1.7901247      0.80981478E-01
         4   1.8891205      0.52009551E-02
         5   1.8955464      -.42662551E-04
         6   1.8954941      0.15801279E-06
         7   1.8954943      0.47618576E-11
         8   1.8954943       0.0000000    
         0   1.8954943       0.0000000    
 
f_02(x) = 2 * x - exp ( - x )
 
    STATUS      X               F(X)
 
         1   0.0000000      -1.0000000    
         2   1.0000000       1.6321206    
         3  0.37992181      0.75928731E-01
         4  0.35311057      0.37216264E-02
         5  0.35173382      0.28266510E-06
         6  0.35173371      0.10261791E-11
         7  0.35173371       0.0000000    
         0  0.35173371       0.0000000    
 
f_03(x) = x * exp ( - x )
 
    STATUS      X               F(X)
 
         1  -1.0000000      -2.7182818    
         2  0.50000000      0.30326533    
         3  0.34944865      0.24638811    
         4  -.24852793      -.31864677    
         5  0.88696039E-01  0.81167847E-01
         6  -.13397964E-01  -.13578678E-01
         7  0.12337235E-02  0.12322023E-02
         8  0.16429166E-04  0.16428896E-04
         9  -.40352160E-09  -.40352160E-09
        10  0.66295778E-14  0.66295778E-14
        11  0.26751788E-23  0.26751788E-23
        12  -.22204460E-15  -.22204460E-15
         0  0.26751788E-23  0.26751788E-23
 
f_04(x) = exp ( x ) - 1 / ( 100 * x * x )
 
    STATUS      X               F(X)
 
         1  0.10000000E-03  -999999.00    
         2   20.000000      0.48516520E+09
         3  0.41238033E-01  -4.8382625    
         4  0.41238232E-01  -4.8382055    
         5  0.58141367E-01  -1.8983488    
         6   10.029071       22676.188    
         7  0.58976018E-01  -1.8143247    
         8  0.76997139E-01  -.60671143    
         9   5.0530339       156.49615    
        10  0.96213965E-01  0.20745857E-01
        11  0.95578592E-01  0.56365645E-02
        12  0.95343746E-01  -.21064209E-04
        13  0.95344620E-01  0.73912705E-07
        14  0.95344617E-01  0.96544994E-12
        15  0.95344617E-01  -.22204460E-15
        16  0.95344617E-01  0.64392935E-14
         0  0.95344617E-01  -.22204460E-15
 
f_05(x) = (x+3) * (x-1) * (x-1)
 
    STATUS      X               F(X)
 
         1  -5.0000000      -72.000000    
         2   2.0000000       5.0000000    
         3   1.5454545       1.3523666    
         4   1.3800380      0.63260398    
         5   1.2363083      0.23656223    
         6  -1.8818459       9.2863099    
         7  -3.4409229      -8.6957923    
         8  -2.6869838       4.2550950    
         9  -2.9346952       1.0110372    
        10  -3.0038554      -.61805988E-01
        11  -2.9998712      0.20614464E-02
        12  -2.9999998      0.39685984E-05
        13  -3.0000000      -.85975671E-12
        14  -3.0000000       0.0000000    
         0  -3.0000000       0.0000000    
 
TEST_LOCAL_MIN_ALL
  Test the Brent LOCAL_MIN routine, which seeks
  a local minimizer of a function F(X)
  in an interval [A,B].
 
g_01(x) = ( x - 2 ) * ( x - 2 ) + 1
 
      A                 X             B
    F(A)              F(X)          F(B)
 
      0.00000000      2.00000000      3.14159265
     5.00000         1.00000         2.30323    
 
g_02(x) = x * x + exp ( - x )
 
      A                 X             B
    F(A)              F(X)          F(B)
 
      0.00000000      0.35173370      1.00000000
     1.00000        0.827184         1.36788    
 
g_03(x) = x^4 + 2x^2 + x + 3
 
      A                 X             B
    F(A)              F(X)          F(B)
 
     -2.00000000     -0.23673290      2.00000000
     25.0000         2.87849         29.0000    
 
g_04(x) = exp ( x ) + 1 / ( 100 x )
 
      A                 X             B
    F(A)              F(X)          F(B)
 
      0.00010000      0.09534461      1.00000000
     101.000         1.20492         2.72828    
 
g_05(x) = exp ( x ) - 2x + 1/(100x) - 1/(1000000x^2)
 
      A                 X             B
    F(A)              F(X)          F(B)
 
      0.00020000      0.70320487      2.00000000
     25.9998        0.628026         3.39406    
 
TEST_LOCAL_MIN_RC_ALL
  Test the reverse communication version of 
  the Brent LOCALM routine, which seeks
  a local minimizer of a function F(X)
  in an interval [A,B].
 
g_01(x) = ( x - 2 ) * ( x - 2 ) + 1
 
 
  Step      X                          F(X)
 
     0     0.000000000000000         5.000000000000000    
     0     3.141592653589793         2.303233786730186    
     1     1.199981614864327         1.640029416555091    
     2     1.941611038725466         1.003409270798719    
     3     2.399963229728653         1.159970585134975    
     4     2.000000000000000         1.000000000000000    
     5     2.000000029802322         1.000000000000001    
     6     1.999999970197678         1.000000000000001    
     7     1.999999970197678         1.000000000000001    
 
g_02(x) = x * x + exp ( - x )
 
 
  Step      X                          F(X)
 
     0     0.000000000000000         1.000000000000000    
     0     1.000000000000000         1.367879441171442    
     1    0.3819660112501051        0.8284162845035989    
     2    0.6180339887498948        0.9209690939741497    
     3    0.2360679774997897        0.8454550784427712    
     4    0.3528496811495104        0.8271857093986708    
     5    0.3518917166104074        0.8271840598740323    
     6    0.3517320418182495        0.8271840261312916    
     7    0.3517337036958197        0.8271840261275244    
     8    0.3517337112615478        0.8271840261275243    
     9    0.3517337165027886        0.8271840261275244    
    10    0.3517337165027886        0.8271840261275244    
 
g_03(x) = x^4 + 2x^2 + x + 3
 
 
  Step      X                          F(X)
 
     0    -2.000000000000000         25.00000000000000    
     0     2.000000000000000         29.00000000000000    
     1   -0.4721359549995796         3.023378685249420    
     2    0.4721359549995792         3.967650595248578    
     3    -1.055728090000841         5.415643516089551    
     4   -0.1498138939889126         2.895578253916099    
     5   -0.2226817817160358         2.878951458114974    
     6   -0.2318072413850192         2.878549359863836    
     7   -0.2370561019263440         2.878493033943844    
     8   -0.2367455245027443         2.878492790245848    
     9   -0.2367325704732761         2.878492789873986    
    10   -0.2367329046684402         2.878492789873726    
    11   -0.2367329011408449         2.878492789873726    
    12   -0.2367328976132497         2.878492789873726    
    13   -0.2367327726568989         2.878492789873766    
    14   -0.2367328498841708         2.878492789873733    
    15   -0.2367328793823638         2.878492789873727    
    16   -0.2367328906496710         2.878492789873726    
    17   -0.2367328906496710         2.878492789873726    
 
g_04(x) = exp ( x ) + 1 / ( 100 x )
 
 
  Step      X                          F(X)
 
     0    0.1000000000000000E-03     101.0001000050002    
     0     1.000000000000000         2.728281828459045    
     1    0.3820278146489801         1.491428944564399    
     2    0.6180721853510198         1.871527165190991    
     3    0.2361443707020397         1.308704097842649    
     4    0.1459834439469404         1.225677948134214    
     5    0.9026092675509928E-01     1.205249730835979    
     6    0.6987608932080662E-01     1.215485764492621    
     7    0.1020637327872526         1.205432046585031    
     8    0.9568202682193082E-01     1.204921944013730    
     9    0.9551304332896546E-01     1.204920914847202    
    10    0.9535723006160622E-01     1.204920574455330    
    11    0.9534430133398021E-01     1.204920572533846    
    12    0.9534460687029817E-01     1.204920572532641    
    13    0.9534461723542657E-01     1.204920572532640    
    14    0.9534461865617216E-01     1.204920572532640    
    15    0.9534462007691777E-01     1.204920572532640    
    16    0.9534462007691777E-01     1.204920572532640    
 
g_05(x) = exp ( x ) - 2x + 1/(100x) - 1/(1000000x^2)
 
 
  Step      X                          F(X)
 
     0    0.2000000000000000E-03     25.99980002000133    
     0     2.000000000000000         3.394055848930650    
     1    0.7640556292979601        0.6319409659880333    
     2     1.236144370702040        0.9781158267720461    
     3    0.4722887414040793        0.6802518820559130    
     4    0.6885274466075678        0.6282485878721349    
     5    0.7016460077946312        0.6280282438453870    
     6    0.7030662791367996        0.6280257405372534    
     7    0.7032084067069250        0.6280257206060759    
     8    0.7032048702467216        0.6280257205928642    
     9    0.7032048403471922        0.6280257205928630    
    10    0.7032048298686234        0.6280257205928630    
    11    0.7032048193900549        0.6280257205928637    
    12    0.7032048193900549        0.6280257205928637    
 
TEST_GLOMIN_ALL
  Test the Brent GLOMIN routine, which seeks
  a global minimizer of a function F(X)
  in an interval [A,B],
  given some upper bound M for F".
 
h_01(x) = 2 - x
 
      A                 X             B
    F(A)              F(X)          F(B)
 
      7.00000000      9.00000000      9.00000000
    -5.00000        -7.00000        -7.00000    
 
h_01(x) = 2 - x
 
      A                 X             B
    F(A)              F(X)          F(B)
 
      7.00000000      9.00000000      9.00000000
    -5.00000        -7.00000        -7.00000    
 
h_02(x) = x * x
 
      A                 X             B
    F(A)              F(X)          F(B)
 
     -1.00000000      0.00000000      2.00000000
     1.00000         0.00000         4.00000    
 
h_02(x) = x * x
 
      A                 X             B
    F(A)              F(X)          F(B)
 
     -1.00000000      0.00000000      2.00000000
     1.00000         0.00000         4.00000    
 
h_03(x) = x^3 + x^2
 
      A                 X             B
    F(A)              F(X)          F(B)
 
     -0.50000000      0.00000000      2.00000000
    0.125000        0.931583E-17     12.0000    
 
h_03(x) = x^3 + x^2
 
      A                 X             B
    F(A)              F(X)          F(B)
 
     -0.50000000      0.00000001      2.00000000
    0.125000        0.387210E-16     12.0000    
 
h_04(x) = ( x + sin(x) ) * exp(-x*x)
 
      A                 X             B
    F(A)              F(X)          F(B)
 
    -10.00000000     -0.67957865     10.00000000
   -0.351770E-42   -0.824239        0.351770E-42
 
h_05(x) = ( x - sin(x) ) * exp(-x*x)
 
      A                 X             B
    F(A)              F(X)          F(B)
 
    -10.00000000     -1.19513664     10.00000000
   -0.392246E-42   -0.634905E-01    0.392246E-42
 
BRENT_TEST
  Normal end of execution.
 
12 December 2020   2:14:27.232 PM
STOP 0
ian@ian:~/brent$ cat brent.f90
function glomin ( a, b, c, m, machep, e, t, f, x )

!*****************************************************************************80
!
!! GLOMIN seeks a global minimum of a function F(X) in an interval [A,B].
!
!  Discussion:
!
!    This function assumes that F(X) is twice continuously differentiable
!    over [A,B] and that F''(X) <= M for all X in [A,B].
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    Original FORTRAN77 version by Richard Brent.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Richard Brent,
!    Algorithms for Minimization Without Derivatives,
!    Dover, 2002,
!    ISBN: 0-486-41998-3,
!    LC: QA402.5.B74.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the endpoints of the interval.
!    It must be the case that A < B.
!
!    Input, real ( kind = 8 ) C, an initial guess for the global
!    minimizer.  If no good guess is known, C = A or B is acceptable.
!
!    Input, real ( kind = 8 ) M, the bound on the second derivative.
!
!    Input, real ( kind = 8 ) MACHEP, an estimate for the relative machine
!    precision.
!
!    Input, real ( kind = 8 ) E, a positive tolerance, a bound for the
!    absolute error in the evaluation of F(X) for any X in [A,B].
!
!    Input, real ( kind = 8 ) T, a positive error tolerance.
!
!    Input, external real ( kind = 8 ) F, the name of a user-supplied
!    function, of the form "FUNCTION F ( X )", which evaluates the
!    function whose global minimum is being sought.
!
!    Output, real ( kind = 8 ) X, the estimated value of the abscissa
!    for which F attains its global minimum value in [A,B].
!
!    Output, real ( kind = 8 ) GLOMIN, the value F(X).
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) a0
  real ( kind = 8 ) a2
  real ( kind = 8 ) a3
  real ( kind = 8 ) b
  real ( kind = 8 ) c
  real ( kind = 8 ) d0
  real ( kind = 8 ) d1
  real ( kind = 8 ) d2
  real ( kind = 8 ) e
  real ( kind = 8 ) f
  real ( kind = 8 ) glomin
  real ( kind = 8 ) h
  integer ( kind = 4 ) k
  real ( kind = 8 ) m
  real ( kind = 8 ) m2
  real ( kind = 8 ) machep
  real ( kind = 8 ) p
  real ( kind = 8 ) q
  real ( kind = 8 ) qs
  real ( kind = 8 ) r
  real ( kind = 8 ) s
  real ( kind = 8 ) sc
  real ( kind = 8 ) t
  real ( kind = 8 ) x
  real ( kind = 8 ) y
  real ( kind = 8 ) y0
  real ( kind = 8 ) y1
  real ( kind = 8 ) y2
  real ( kind = 8 ) y3
  real ( kind = 8 ) yb
  real ( kind = 8 ) z0
  real ( kind = 8 ) z1
  real ( kind = 8 ) z2

  a0 = b
  x = a0
  a2 = a
  y0 = f ( b )
  yb = y0
  y2 = f ( a )
  y = y2

  if ( y0 < y ) then
    y = y0
  else
    x = a
  end if

  if ( m <= 0.0D+00 .or. b <= a ) then
    glomin = y
    return
  end if

  m2 = 0.5D+00 * ( 1.0D+00 + 16.0D+00 * machep ) * m

  if ( c <= a .or. b <= c ) then
    sc = 0.5D+00 * ( a + b )
  else
    sc = c
  end if

  y1 = f ( sc )
  k = 3
  d0 = a2 - sc
  h = 9.0D+00 / 11.0D+00

  if ( y1 < y ) then
    x = sc
    y = y1
  end if

  do

    d1 = a2 - a0
    d2 = sc - a0
    z2 = b - a2
    z0 = y2 - y1
    z1 = y2 - y0
    r = d1 * d1 * z0 - d0 * d0 * z1
    p = r
    qs = 2.0D+00 * ( d0 * z1 - d1 * z0 )
    q = qs

    if ( k < 1000000 .or. y2 <= y ) then

      do

        if ( q * ( r * ( yb - y2 ) + z2 * q * ( ( y2 - y ) + t ) ) < &
          z2 * m2 * r * ( z2 * q - r ) ) then
          a3 = a2 + r / q
          y3 = f ( a3 )

          if ( y3 < y ) then
            x = a3
            y = y3
          end if
        end if

        k = mod ( 1611 * k, 1048576 )
        q = 1.0D+00
        r = ( b - a ) * 0.00001D+00 * real ( k, kind = 8 )

        if ( z2 <= r ) then
          exit
        end if

      end do

    else

      k = mod ( 1611 * k, 1048576 )
      q = 1.0D+00
      r = ( b - a ) * 0.00001D+00 * real ( k, kind = 8 )

      do while ( r < z2 )

        if ( q * ( r * ( yb - y2 ) + z2 * q * ( ( y2 - y ) + t ) ) < &
          z2 * m2 * r * ( z2 * q - r ) ) then
          a3 = a2 + r / q
          y3 = f ( a3 )

          if ( y3 < y ) then
            x = a3
            y = y3
          end if
        end if

        k = mod ( 1611 * k, 1048576 )
        q = 1.0D+00
        r = ( b - a ) * 0.00001D+00 * real ( k, kind = 8 )

      end do

    end if

    r = m2 * d0 * d1 * d2
    s = sqrt ( ( ( y2 - y ) + t ) / m2 )
    h = 0.5D+00 * ( 1.0D+00 + h )
    p = h * ( p + 2.0D+00 * r * s )
    q = q + 0.5D+00 * qs
    r = - 0.5D+00 * ( d0 + ( z0 + 2.01D+00 * e ) / ( d0 * m2 ) )

    if ( r < s .or. d0 < 0.0D+00 ) then
      r = a2 + s
    else
      r = a2 + r
    end if

    if ( 0.0D+00 < p * q ) then
      a3 = a2 + p / q
    else
      a3 = r
    end if

    do

      a3 = max ( a3, r )

      if ( b <= a3 ) then
        a3 = b
        y3 = yb
      else
        y3 = f ( a3 )
      end if

      if ( y3 < y ) then
        x = a3
        y = y3
      end if

      d0 = a3 - a2

      if ( a3 <= r ) then
        exit
      end if

      p = 2.0D+00 * ( y2 - y3 ) / ( m * d0 )

      if ( ( 1.0D+00 + 9.0D+00 * machep ) * d0 <= abs ( p ) ) then
        exit
      end if

      if ( 0.5D+00 * m2 * ( d0 * d0 + p * p ) <= &
        ( y2 - y ) + ( y3 - y ) + 2.0D+00 * t ) then
        exit
      end if

      a3 = 0.5D+00 * ( a2 + a3 )
      h = 0.9D+00 * h

    end do

    if ( b <= a3 ) then
      exit
    end if

    a0 = sc
    sc = a2
    a2 = a3
    y0 = y1
    y1 = y2
    y2 = y3

  end do

  glomin = y

  return
end
function local_min ( a, b, eps, t, f, x )

!*****************************************************************************80
!
!! LOCAL_MIN seeks a local minimum of a function F(X) in an interval [A,B].
!
!  Discussion:
!
!    If the function F is defined on the interval (A,B), then local_min
!    finds an approximation X to the point at which F attatains its minimum
!    (or the appropriate limit point), and returns the value of F at X.
!
!    T and EPS define a tolerance TOL = EPS * abs ( X ) + T.
!    F is never evaluated at two points closer than TOL.  
!
!    If F is delta-unimodal for some delta less than TOL, the X approximates
!    the global minimum of F with an error less than 3*TOL.
!
!    If F is not delta-unimodal, then X may approximate a local, but 
!    perhaps non-global, minimum.
!
!    The method used is a combination of golden section search and
!    successive parabolic interpolation.  Convergence is never much slower
!    than that for a Fibonacci search.  If F has a continuous second
!    derivative which is positive at the minimum (which is not at A or
!    B), then, ignoring rounding errors, convergence is superlinear, and 
!    usually of the order of about 1.3247.
!
!    Thanks to Jonathan Eggleston for pointing out a correction to the 
!    golden section step, 01 July 2013.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    01 July 2013
!
!  Author:
!
!    Original FORTRAN77 version by Richard Brent.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Richard Brent,
!    Algorithms for Minimization Without Derivatives,
!    Dover, 2002,
!    ISBN: 0-486-41998-3,
!    LC: QA402.5.B74.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the endpoints of the interval.
!
!    Input, real ( kind = 8 ) EPS, a positive relative error tolerance.
!    EPS should be no smaller than twice the relative machine precision,
!    and preferably not much less than the square root of the relative
!    machine precision.
!
!    Input, real ( kind = 8 ) T, a positive absolute error tolerance.
!
!    Input, external real ( kind = 8 ) F, the name of a user-supplied
!    function, of the form "FUNCTION F ( X )", which evaluates the
!    function whose local minimum is being sought.
!
!    Output, real ( kind = 8 ) X, the estimated value of an abscissa
!    for which F attains a local minimum value in [A,B].
!
!    Output, real ( kind = 8 ) LOCAL_MIN, the value F(X).
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ) c
  real ( kind = 8 ) d
  real ( kind = 8 ) e
  real ( kind = 8 ) eps
  real ( kind = 8 ) f
  real ( kind = 8 ) fu
  real ( kind = 8 ) fv
  real ( kind = 8 ) fw
  real ( kind = 8 ) fx
  real ( kind = 8 ) local_min
  real ( kind = 8 ) m
  real ( kind = 8 ) p
  real ( kind = 8 ) q
  real ( kind = 8 ) r
  real ( kind = 8 ) sa
  real ( kind = 8 ) sb
  real ( kind = 8 ) t
  real ( kind = 8 ) t2
  real ( kind = 8 ) tol
  real ( kind = 8 ) u
  real ( kind = 8 ) v
  real ( kind = 8 ) w
  real ( kind = 8 ) x
!
!  C is the square of the inverse of the golden ratio.
!
  c = 0.5D+00 * ( 3.0D+00 - sqrt ( 5.0D+00 ) )

  sa = a
  sb = b
  x = sa + c * ( b - a )
  w = x
  v = w
  e = 0.0D+00
  fx = f ( x )
  fw = fx
  fv = fw

  do

    m = 0.5D+00 * ( sa + sb ) 
    tol = eps * abs ( x ) + t
    t2 = 2.0D+00 * tol
!
!  Check the stopping criterion.
!
    if ( abs ( x - m ) <= t2 - 0.5D+00 * ( sb - sa ) ) then
      exit
    end if
!
!  Fit a parabola.
!
    r = 0.0D+00
    q = r
    p = q

    if ( tol < abs ( e ) ) then

      r = ( x - w ) * ( fx - fv )
      q = ( x - v ) * ( fx - fw )
      p = ( x - v ) * q - ( x - w ) * r
      q = 2.0D+00 * ( q - r )

      if ( 0.0D+00 < q ) then
        p = - p
      end if

      q = abs ( q )

      r = e
      e = d

    end if

    if ( abs ( p ) < abs ( 0.5D+00 * q * r ) .and. &
         q * ( sa - x ) < p .and. &
         p < q * ( sb - x ) ) then
!
!  Take the parabolic interpolation step.
!
      d = p / q
      u = x + d
!
!  F must not be evaluated too close to A or B.
!
      if ( ( u - sa ) < t2 .or. ( sb - u ) < t2 ) then

        if ( x < m ) then
          d = tol
        else
          d = - tol
        end if

      end if
!
!  A golden-section step.
!
    else

      if ( x < m ) then
        e = sb - x
      else
        e = sa - x
      end if

      d = c * e

    end if
!
!  F must not be evaluated too close to X.
!
    if ( tol <= abs ( d ) ) then
      u = x + d
    else if ( 0.0D+00 < d ) then
      u = x + tol
    else
      u = x - tol
    end if

    fu = f ( u )
!
!  Update A, B, V, W, and X.
!
    if ( fu <= fx ) then

      if ( u < x ) then
        sb = x
      else
        sa = x
      end if

      v = w
      fv = fw
      w = x
      fw = fx
      x = u
      fx = fu

    else

      if ( u < x ) then
        sa = u
      else
        sb = u
      end if

      if ( fu <= fw .or. w == x ) then
        v = w
        fv = fw
        w = u
        fw = fu
      else if ( fu <= fv .or. v == x .or. v == w ) then
        v = u
        fv = fu
      end if

    end if

  end do

  local_min = fx

  return
end
subroutine local_min_rc ( a, b, arg, status, value )

!*****************************************************************************80
!
!! LOCAL_MIN_RC seeks a minimizer of a scalar function of a scalar variable.
!
!  Discussion:
!
!    This routine seeks an approximation to the point where a function
!    F attains a minimum on the interval (A,B).
!
!    The method used is a combination of golden section search and
!    successive parabolic interpolation.  Convergence is never much
!    slower than that for a Fibonacci search.  If F has a continuous
!    second derivative which is positive at the minimum (which is not
!    at A or B), then convergence is superlinear, and usually of the
!    order of about 1.324...
!
!    The routine is a revised version of the Brent local minimization 
!    algorithm, using reverse communication.
!
!    It is worth stating explicitly that this routine will NOT be
!    able to detect a minimizer that occurs at either initial endpoint
!    A or B.  If this is a concern to the user, then the user must
!    either ensure that the initial interval is larger, or to check
!    the function value at the returned minimizer against the values
!    at either endpoint.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    22 October 2004
!
!  Author:
!
!    John Burkardt
!
!  Reference:
!
!    Richard Brent,
!    Algorithms for Minimization Without Derivatives,
!    Dover, 2002,
!    ISBN: 0-486-41998-3,
!    LC: QA402.5.B74.
!
!    David Kahaner, Cleve Moler, Steven Nash,
!    Numerical Methods and Software,
!    Prentice Hall, 1989,
!    ISBN: 0-13-627258-4,
!    LC: TA345.K34.
!
!  Parameters
!
!    Input/output, real ( kind = 8 ) A, B.  On input, the left and right
!    endpoints of the initial interval.  On output, the lower and upper
!    bounds for an interval containing the minimizer.  It is required
!    that A < B.
!
!    Output, real ( kind = 8 ) ARG, the currently considered point.  The user
!    does not need to initialize this value.  On return with STATUS positive,
!    the user is requested to evaluate the function at ARG, and return
!    the value in VALUE.  On return with STATUS zero, ARG is the routine's
!    estimate for the function minimizer.
!
!    Input/output, integer ( kind = 4 ) STATUS, used to communicate between 
!    the user and the routine.  The user only sets STATUS to zero on the first 
!    call, to indicate that this is a startup call.  The routine returns STATUS
!    positive to request that the function be evaluated at ARG, or returns
!    STATUS as 0, to indicate that the iteration is complete and that
!    ARG is the estimated minimizer.
!
!    Input, real ( kind = 8 ) VALUE, the function value at ARG, as requested
!    by the routine on the previous call.
!
!  Local parameters:
!
!    C is the squared inverse of the golden ratio.
!
!    EPS is the square root of the relative machine precision.
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) arg
  real ( kind = 8 ) b
  real ( kind = 8 ), save :: c
  real ( kind = 8 ), save :: d
  real ( kind = 8 ), save :: e
  real ( kind = 8 ), save :: eps
  real ( kind = 8 ), save :: fu
  real ( kind = 8 ), save :: fv
  real ( kind = 8 ), save :: fw
  real ( kind = 8 ), save :: fx
  real ( kind = 8 ), save :: midpoint
  real ( kind = 8 ), save :: p
  real ( kind = 8 ), save :: q
  real ( kind = 8 ), save :: r
  integer ( kind = 4 ) status
  real ( kind = 8 ), save :: tol
  real ( kind = 8 ), save :: tol1
  real ( kind = 8 ), save :: tol2
  real ( kind = 8 ), save :: u
  real ( kind = 8 ), save :: v
  real ( kind = 8 ) value
  real ( kind = 8 ), save :: w
  real ( kind = 8 ), save :: x
!
!  STATUS (INPUT) = 0, startup.
!
  if ( status == 0 ) then

    if ( b <= a ) then
      write ( *, '(a)' ) ' '
      write ( *, '(a)' ) 'LOCAL_MIN_RC - Fatal error!'
      write ( *, '(a)' ) '  A < B is required, but'
      write ( *, '(a,g14.6)' ) '  A = ', a
      write ( *, '(a,g14.6)' ) '  B = ', b
      status = -1
      stop 1
    end if

    c = 0.5D+00 * ( 3.0D+00 - sqrt ( 5.0D+00 ) )

    eps = sqrt ( epsilon ( eps ) )
    tol = epsilon ( tol )

    v = a + c * ( b - a )
    w = v
    x = v
    e = 0.0D+00

    status = 1
    arg = x

    return
!
!  STATUS (INPUT) = 1, return with initial function value of FX.
!
  else if ( status == 1 ) then

    fx = value
    fv = fx
    fw = fx
!
!  STATUS (INPUT) = 2 or more, update the data.
!
  else if ( 2 <= status ) then

    fu = value

    if ( fu <= fx ) then

      if ( x <= u ) then
        a = x
      else
        b = x
      end if

      v = w
      fv = fw
      w = x
      fw = fx
      x = u
      fx = fu

    else

      if ( u < x ) then
        a = u
      else
        b = u
      end if

      if ( fu <= fw .or. w == x ) then
        v = w
        fv = fw
        w = u
        fw = fu
      else if ( fu <= fv .or. v == x .or. v == w ) then
        v = u
        fv = fu
      end if

    end if

  end if
!
!  Take the next step.
!
  midpoint = 0.5D+00 * ( a + b )
  tol1 = eps * abs ( x ) + tol / 3.0D+00
  tol2 = 2.0D+00 * tol1
!
!  If the stopping criterion is satisfied, we can exit.
!
  if ( abs ( x - midpoint ) <= ( tol2 - 0.5D+00 * ( b - a ) ) ) then
    status = 0
    return
  end if
!
!  Is golden-section necessary?
!
  if ( abs ( e ) <= tol1 ) then

    if ( midpoint <= x ) then
      e = a - x
    else
      e = b - x
    end if

    d = c * e
!
!  Consider fitting a parabola.
!
  else

    r = ( x - w ) * ( fx - fv )
    q = ( x - v ) * ( fx - fw )
    p = ( x - v ) * q - ( x - w ) * r
    q = 2.0D+00 * ( q - r )
    if ( 0.0D+00 < q ) then
      p = - p
    end if
    q = abs ( q )
    r = e
    e = d
!
!  Choose a golden-section step if the parabola is not advised.
!
    if ( &
      ( abs ( 0.5D+00 * q * r ) <= abs ( p ) ) .or. &
      ( p <= q * ( a - x ) ) .or. &
      ( q * ( b - x ) <= p ) ) then

      if ( midpoint <= x ) then
        e = a - x
      else
        e = b - x
      end if

      d = c * e
!
!  Choose a parabolic interpolation step.
!
    else

      d = p / q
      u = x + d

      if ( ( u - a ) < tol2 ) then
        d = sign ( tol1, midpoint - x )
      end if

      if ( ( b - u ) < tol2 ) then
        d = sign ( tol1, midpoint - x )
      end if

    end if

  end if
!
!  F must not be evaluated too close to X.
!
  if ( tol1 <= abs ( d ) ) then
    u = x + d
  end if

  if ( abs ( d ) < tol1 ) then
    u = x + sign ( tol1, d )
  end if
!
!  Request value of F(U).
!
  arg = u
  status = status + 1

  return
end
subroutine timestamp ( )

!*****************************************************************************80
!
!! TIMESTAMP prints the current YMDHMS date as a time stamp.
!
!  Example:
!
!    31 May 2001   9:45:54.872 AM
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    18 May 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    None
!
  implicit none

  character ( len = 8 ) ampm
  integer ( kind = 4 ) d
  integer ( kind = 4 ) h
  integer ( kind = 4 ) m
  integer ( kind = 4 ) mm
  character ( len = 9 ), parameter, dimension(12) :: month = (/ &
    'January  ', 'February ', 'March    ', 'April    ', &
    'May      ', 'June     ', 'July     ', 'August   ', &
    'September', 'October  ', 'November ', 'December ' /)
  integer ( kind = 4 ) n
  integer ( kind = 4 ) s
  integer ( kind = 4 ) values(8)
  integer ( kind = 4 ) y

  call date_and_time ( values = values )

  y = values(1)
  m = values(2)
  d = values(3)
  h = values(5)
  n = values(6)
  s = values(7)
  mm = values(8)

  if ( h < 12 ) then
    ampm = 'AM'
  else if ( h == 12 ) then
    if ( n == 0 .and. s == 0 ) then
      ampm = 'Noon'
    else
      ampm = 'PM'
    end if
  else
    h = h - 12
    if ( h < 12 ) then
      ampm = 'PM'
    else if ( h == 12 ) then
      if ( n == 0 .and. s == 0 ) then
        ampm = 'Midnight'
      else
        ampm = 'AM'
      end if
    end if
  end if

  write ( *, '(i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) &
    d, trim ( month(m) ), y, h, ':', n, ':', s, '.', mm, trim ( ampm )

  return
end
function zero ( a, b, machep, t, f )

!*****************************************************************************80
!
!! ZERO seeks the root of a function F(X) in an interval [A,B].
!
!  Discussion:
!
!    The interval [A,B] must be a change of sign interval for F.
!    That is, F(A) and F(B) must be of opposite signs.  Then
!    assuming that F is continuous implies the existence of at least
!    one value C between A and B for which F(C) = 0.
!
!    The location of the zero is determined to within an accuracy
!    of 6 * MACHEPS * abs ( C ) + 2 * T.
!
!    Thanks to Thomas Secretin for pointing out a transcription error in the
!    setting of the value of P, 11 February 2013.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    11 February 2013
!
!  Author:
!
!    Original FORTRAN77 version by Richard Brent.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Richard Brent,
!    Algorithms for Minimization Without Derivatives,
!    Dover, 2002,
!    ISBN: 0-486-41998-3,
!    LC: QA402.5.B74.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the endpoints of the change of 
!    sign interval.
!
!    Input, real ( kind = 8 ) MACHEP, an estimate for the relative machine
!    precision.
!
!    Input, real ( kind = 8 ) T, a positive error tolerance.
!
!    Input, external real ( kind = 8 ) F, the name of a user-supplied
!    function, of the form "FUNCTION F ( X )", which evaluates the
!    function whose zero is being sought.
!
!    Output, real ( kind = 8 ) ZERO, the estimated value of a zero of
!    the function F.
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ) c
  real ( kind = 8 ) d
  real ( kind = 8 ) e
  real ( kind = 8 ) f
  real ( kind = 8 ) fa
  real ( kind = 8 ) fb
  real ( kind = 8 ) fc
  real ( kind = 8 ) m
  real ( kind = 8 ) machep
  real ( kind = 8 ) p
  real ( kind = 8 ) q
  real ( kind = 8 ) r
  real ( kind = 8 ) s
  real ( kind = 8 ) sa
  real ( kind = 8 ) sb
  real ( kind = 8 ) t
  real ( kind = 8 ) tol
  real ( kind = 8 ) zero
!
!  Make local copies of A and B.
!
  sa = a
  sb = b
  fa = f ( sa )
  fb = f ( sb )

  c = sa
  fc = fa
  e = sb - sa
  d = e

  do

    if ( abs ( fc ) < abs ( fb ) ) then

      sa = sb
      sb = c
      c = sa
      fa = fb
      fb = fc
      fc = fa

    end if

    tol = 2.0D+00 * machep * abs ( sb ) + t
    m = 0.5D+00 * ( c - sb )

    if ( abs ( m ) <= tol .or. fb == 0.0D+00 ) then
      exit
    end if

    if ( abs ( e ) < tol .or. abs ( fa ) <= abs ( fb ) ) then

      e = m
      d = e

    else

      s = fb / fa

      if ( sa == c ) then

        p = 2.0D+00 * m * s
        q = 1.0D+00 - s

      else

        q = fa / fc
        r = fb / fc
        p = s * ( 2.0D+00 * m * q * ( q - r ) - ( sb - sa ) * ( r - 1.0D+00 ) )
        q = ( q - 1.0D+00 ) * ( r - 1.0D+00 ) * ( s - 1.0D+00 )

      end if

      if ( 0.0D+00 < p ) then
        q = - q
      else
        p = - p
      end if

      s = e
      e = d

      if ( 2.0D+00 * p < 3.0D+00 * m * q - abs ( tol * q ) .and. &
        p < abs ( 0.5D+00 * s * q ) ) then
        d = p / q
      else
        e = m
        d = e
      end if

    end if

    sa = sb
    fa = fb

    if ( tol < abs ( d ) ) then
      sb = sb + d
    else if ( 0.0D+00 < m ) then
      sb = sb + tol
    else
      sb = sb - tol
    end if

    fb = f ( sb )

    if ( ( 0.0D+00 < fb .and. 0.0D+00 < fc ) .or. &
         ( fb <= 0.0D+00 .and. fc <= 0.0D+00 ) ) then
      c = sa
      fc = fa
      e = sb - sa
      d = e
    end if

  end do

  zero = sb

  return
end
subroutine zero_rc ( a, b, t, arg, status, value )

!*****************************************************************************80
!
!! ZERO_RC seeks the root of a function F(X) using reverse communication.
!
!  Discussion:
!
!    The interval [A,B] must be a change of sign interval for F.
!    That is, F(A) and F(B) must be of opposite signs.  Then
!    assuming that F is continuous implies the existence of at least
!    one value C between A and B for which F(C) = 0.
!
!    The location of the zero is determined to within an accuracy
!    of 6 * MACHEPS * abs ( C ) + 2 * T.
!
!    The routine is a revised version of the Brent zero finder 
!    algorithm, using reverse communication.
!
!    Thanks to Thomas Secretin for pointing out a transcription error in the
!    setting of the value of P, 11 February 2013.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    11 February 2013
!
!  Author:
!
!    John Burkardt
!
!  Reference:
!
!    Richard Brent,
!    Algorithms for Minimization Without Derivatives,
!    Dover, 2002,
!    ISBN: 0-486-41998-3,
!    LC: QA402.5.B74.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the endpoints of the change of 
!    sign interval.
!
!    Input, real ( kind = 8 ) T, a positive error tolerance.
!
!    Output, real ( kind = 8 ) ARG, the currently considered point.  The user
!    does not need to initialize this value.  On return with STATUS positive,
!    the user is requested to evaluate the function at ARG, and return
!    the value in VALUE.  On return with STATUS zero, ARG is the routine's
!    estimate for the function's zero.
!
!    Input/output, integer ( kind = 4 ) STATUS, used to communicate between 
!    the user and the routine.  The user only sets STATUS to zero on the first 
!    call, to indicate that this is a startup call.  The routine returns STATUS
!    positive to request that the function be evaluated at ARG, or returns
!    STATUS as 0, to indicate that the iteration is complete and that
!    ARG is the estimated zero
!
!    Input, real ( kind = 8 ) VALUE, the function value at ARG, as requested
!    by the routine on the previous call.
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) arg
  real ( kind = 8 ) b
  real ( kind = 8 ), save :: c
  real ( kind = 8 ), save :: d
  real ( kind = 8 ), save :: e
  real ( kind = 8 ), save :: fa
  real ( kind = 8 ), save :: fb
  real ( kind = 8 ), save :: fc
  real ( kind = 8 ) m
  real ( kind = 8 ), save :: machep
  real ( kind = 8 ) p
  real ( kind = 8 ) q
  real ( kind = 8 ) r
  real ( kind = 8 ) s
  real ( kind = 8 ), save :: sa
  real ( kind = 8 ), save :: sb
  integer ( kind = 4 ) status
  real ( kind = 8 ) t
  real ( kind = 8 ) tol
  real ( kind = 8 ) value
!
!  Input STATUS = 0.
!  Initialize, request F(A).
!
  if ( status == 0 ) then

    machep = epsilon ( a )

    sa = a
    sb = b
    e = sb - sa
    d = e

    status = 1
    arg = a
    return
!
!  Input STATUS = 1.
!  Receive F(A), request F(B).
!
  else if ( status == 1 ) then

    fa = value

    status = 2
    arg = sb
    return
!
!  Input STATUS = 2
!  Receive F(B).
!
  else if ( status == 2 ) then

    fb = value

    if ( 0.0D+00 < fa * fb ) then
      status = -1
      return
    end if

    c = sa
    fc = fa

  else

    fb = value

    if ( ( 0.0D+00 < fb .and. 0.0D+00 < fc ) .or. &
         ( fb <= 0.0D+00 .and. fc <= 0.0D+00 ) ) then
      c = sa
      fc = fa
      e = sb - sa
      d = e
    end if

  end if
!
!  Compute the next point at which a function value is requested.
!
  if ( abs ( fc ) < abs ( fb ) ) then

    sa = sb
    sb = c
    c = sa
    fa = fb
    fb = fc
    fc = fa

  end if

  tol = 2.0D+00 * machep * abs ( sb ) + t
  m = 0.5D+00 * ( c - sb )

  if ( abs ( m ) <= tol .or. fb == 0.0D+00 ) then
    status = 0
    arg = sb
    return
  end if

  if ( abs ( e ) < tol .or. abs ( fa ) <= abs ( fb ) ) then

    e = m
    d = e

  else

    s = fb / fa

    if ( sa == c ) then

      p = 2.0D+00 * m * s
      q = 1.0D+00 - s

    else

      q = fa / fc
      r = fb / fc
      p = s * ( 2.0D+00 * m * q * ( q - r ) - ( sb - sa ) * ( r - 1.0D+00 ) )
      q = ( q - 1.0D+00 ) * ( r - 1.0D+00 ) * ( s - 1.0D+00 )

    end if

    if ( 0.0D+00 < p ) then
      q = - q
    else
      p = - p
    end if

    s = e
    e = d

    if ( 2.0D+00 * p < 3.0D+00 * m * q - abs ( tol * q ) .and. &
      p < abs ( 0.5D+00 * s * q ) ) then
      d = p / q
    else
      e = m
      d = e
    end if

  end if

  sa = sb
  fa = fb

  if ( tol < abs ( d ) ) then
    sb = sb + d
  else if ( 0.0D+00 < m ) then
    sb = sb + tol
  else
    sb = sb - tol
  end if

  arg = sb
  status = status + 1

  return
end
ian@ian:~/brent$ cat brent_test.f90
program main

!*****************************************************************************80
!
!! MAIN is the main program for BRENT_TEST.
!
!  Discussion:
!
!    BRENT_TEST tests the BRENT library.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    14 October 2008
!
!  Author:
!
!    John Burkardt
!
  implicit none

  call timestamp ( )
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) 'BRENT_TEST'
  write ( *, '(a)' ) '  FORTRAN90 version.'
  write ( *, '(a)' ) '  Test the BRENT library.'

  call test_zero_all ( )
  call test_zero_rc_all ( )
  call test_local_min_all ( )
  call test_local_min_rc_all ( )
  call test_glomin_all ( )
!
!  Terminate.
!
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) 'BRENT_TEST'
  write ( *, '(a)' ) '  Normal end of execution.'
  write ( *, '(a)' ) ' '
  call timestamp ( )

  stop 0
end
subroutine test_zero_all ( )

!*****************************************************************************80
!
!! TEST_ZERO_ALL tests Brent's zero finding routine on all test functions.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ), external :: f_01
  real ( kind = 8 ), external :: f_02
  real ( kind = 8 ), external :: f_03
  real ( kind = 8 ), external :: f_04
  real ( kind = 8 ), external :: f_05
  real ( kind = 8 ) machep
  real ( kind = 8 ) t

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) 'TEST_ZERO_ALL'
  write ( *, '(a)' ) '  Test the Brent ZERO routine, which seeks'
  write ( *, '(a)' ) '  a root of a function F(X)'
  write ( *, '(a)' ) '  in an interval [A,B].'

  machep = epsilon ( machep )
  t = machep

  a = 1.0D+00
  b = 2.0D+00

  call test_zero_one ( a, b, machep, t, f_01, &
    'f_01(x) = sin ( x ) - x / 2' )

  a = 0.0D+00
  b = 1.0D+00

  call test_zero_one ( a, b, machep, t, f_02, &
    'f_02(x) = 2 * x - exp ( - x )' )

  a = -1.0D+00
  b =  0.5D+00

  call test_zero_one ( a, b, machep, t, f_03, &
    'f_03(x) = x * exp ( - x )' )

  a =  0.0001D+00
  b =  20.0D+00

  call test_zero_one ( a, b, machep, t, f_04, &
    'f_04(x) = exp ( x ) - 1 / ( 100 * x * x )' )

  a = -5.0D+00
  b =  2.0D+00

  call test_zero_one ( a, b, machep, t, f_05, &
    'f_05(x) = (x+3) * (x-1) * (x-1)' )

  return
end
subroutine test_zero_rc_all ( )

!*****************************************************************************80
!
!! TEST_ZERO_RC_ALL tests Brent's zero finding routine on all test functions.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    14 October 2008
!
!  Author:
!
!    John Burkardt
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ), external :: f_01
  real ( kind = 8 ), external :: f_02
  real ( kind = 8 ), external :: f_03
  real ( kind = 8 ), external :: f_04
  real ( kind = 8 ), external :: f_05
  real ( kind = 8 ) machep
  real ( kind = 8 ) t

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) 'TEST_ZERO_RC_ALL'
  write ( *, '(a)' ) '  Test the reverse communication version of the Brent ZERO'
  write ( *, '(a)' ) '  routine, which seeks a root of a function F(X)'
  write ( *, '(a)' ) '  in an interval [A,B].'

  machep = epsilon ( machep )
  t = machep

  a = 1.0D+00
  b = 2.0D+00

  call test_zero_rc_one ( a, b, machep, t, f_01, &
    'f_01(x) = sin ( x ) - x / 2' )

  a = 0.0D+00
  b = 1.0D+00

  call test_zero_rc_one ( a, b, machep, t, f_02, &
    'f_02(x) = 2 * x - exp ( - x )' )

  a = -1.0D+00
  b =  0.5D+00

  call test_zero_rc_one ( a, b, machep, t, f_03, &
    'f_03(x) = x * exp ( - x )' )

  a =  0.0001D+00
  b =  20.0D+00

  call test_zero_rc_one ( a, b, machep, t, f_04, &
    'f_04(x) = exp ( x ) - 1 / ( 100 * x * x )' )

  a = -5.0D+00
  b =  2.0D+00

  call test_zero_rc_one ( a, b, machep, t, f_05, &
    'f_05(x) = (x+3) * (x-1) * (x-1)' )

  return
end
subroutine test_local_min_all ( )

!*****************************************************************************80
!
!! TEST_LOCAL_MIN_ALL tests Brent's local minimizer on all test functions.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ) eps
  real ( kind = 8 ), external :: g_01
  real ( kind = 8 ), external :: g_02
  real ( kind = 8 ), external :: g_03
  real ( kind = 8 ), external :: g_04
  real ( kind = 8 ), external :: g_05
  real ( kind = 8 ) t

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) 'TEST_LOCAL_MIN_ALL'
  write ( *, '(a)' ) '  Test the Brent LOCAL_MIN routine, which seeks'
  write ( *, '(a)' ) '  a local minimizer of a function F(X)'
  write ( *, '(a)' ) '  in an interval [A,B].'

  eps = 10.0D+00 * sqrt ( epsilon ( eps ) )
  t = eps

  a = 0.0D+00
  b = 3.141592653589793D+00

  call test_local_min_one ( a, b, eps, t, g_01, &
    'g_01(x) = ( x - 2 ) * ( x - 2 ) + 1' )

  a = 0.0D+00
  b = 1.0D+00

  call test_local_min_one ( a, b, eps, t, g_02, &
    'g_02(x) = x * x + exp ( - x )' )

  a = -2.0D+00
  b =  2.0D+00

  call test_local_min_one ( a, b, eps, t, g_03, &
    'g_03(x) = x^4 + 2x^2 + x + 3' )

  a =  0.0001D+00
  b =  1.0D+00

  call test_local_min_one ( a, b, eps, t, g_04, &
    'g_04(x) = exp ( x ) + 1 / ( 100 x )' )

  a =  0.0002D+00
  b = 2.0D+00

  call test_local_min_one ( a, b, eps, t, g_05, &
    'g_05(x) = exp ( x ) - 2x + 1/(100x) - 1/(1000000x^2)' )

  return
end
subroutine test_local_min_rc_all ( )

!*****************************************************************************80
!
!! TEST_LOCAL_MIN_RC_ALL tests LOCAL_MIN_RC on all test functions.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    13 April 2008
!
!  Author:
!
!    John Burkardt
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ), external :: g_01
  real ( kind = 8 ), external :: g_02
  real ( kind = 8 ), external :: g_03
  real ( kind = 8 ), external :: g_04
  real ( kind = 8 ), external :: g_05
  real ( kind = 8 ) t

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) 'TEST_LOCAL_MIN_RC_ALL'
  write ( *, '(a)' ) '  Test the reverse communication version of '
  write ( *, '(a)' ) '  the Brent LOCALM routine, which seeks'
  write ( *, '(a)' ) '  a local minimizer of a function F(X)'
  write ( *, '(a)' ) '  in an interval [A,B].'

  t = 10.0D+00 * sqrt ( epsilon ( t ) )

  a = 0.0D+00
  b = 3.141592653589793D+00

  call test_local_min_rc_one ( a, b, t, g_01, &
    'g_01(x) = ( x - 2 ) * ( x - 2 ) + 1' )

  a = 0.0D+00
  b = 1.0D+00

  call test_local_min_rc_one ( a, b, t, g_02, &
    'g_02(x) = x * x + exp ( - x )' )

  a = -2.0D+00
  b =  2.0D+00

  call test_local_min_rc_one ( a, b, t, g_03, &
    'g_03(x) = x^4 + 2x^2 + x + 3' )

  a =  0.0001D+00
  b =  1.0D+00

  call test_local_min_rc_one ( a, b, t, g_04, &
    'g_04(x) = exp ( x ) + 1 / ( 100 x )' )

  a =  0.0002D+00
  b = 2.0D+00

  call test_local_min_rc_one ( a, b, t, g_05, &
    'g_05(x) = exp ( x ) - 2x + 1/(100x) - 1/(1000000x^2)' )

  return
end
subroutine test_glomin_all ( )

!*****************************************************************************80
!
!! TEST_GLOMIN_ALL tests the Brent global minimizer on all test functions.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ) c
  real ( kind = 8 ) e
  real ( kind = 8 ), external :: h_01
  real ( kind = 8 ), external :: h_02
  real ( kind = 8 ), external :: h_03
  real ( kind = 8 ), external :: h_04
  real ( kind = 8 ), external :: h_05
  real ( kind = 8 ) m
  real ( kind = 8 ) machep
  real ( kind = 8 ) t

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) 'TEST_GLOMIN_ALL'
  write ( *, '(a)' ) '  Test the Brent GLOMIN routine, which seeks'
  write ( *, '(a)' ) '  a global minimizer of a function F(X)'
  write ( *, '(a)' ) '  in an interval [A,B],'
  write ( *, '(a)' ) '  given some upper bound M for F".'

  machep = epsilon ( machep )
  e = sqrt ( machep )
  t = sqrt ( machep )

  a = 7.0D+00
  b = 9.0D+00
  c = ( a + b ) / 2.0D+00
  m = 0.0D+00

  call test_glomin_one ( a, b, c, m, machep, e, t, h_01, &
    'h_01(x) = 2 - x' )

  a = 7.0D+00
  b = 9.0D+00
  c = ( a + b ) / 2.0D+00
  m = 100.0D+00

  call test_glomin_one ( a, b, c, m, machep, e, t, h_01, &
    'h_01(x) = 2 - x' )

  a = -1.0D+00
  b = +2.0D+00
  c = ( a + b ) / 2.0D+00
  m = 2.0D+00

  call test_glomin_one ( a, b, c, m, machep, e, t, h_02, &
    'h_02(x) = x * x' )

  a = -1.0D+00
  b = +2.0D+00
  c = ( a + b ) / 2.0D+00
  m = 2.1D+00

  call test_glomin_one ( a, b, c, m, machep, e, t, h_02, &
    'h_02(x) = x * x' )

  a = -0.5D+00
  b =  +2.0D+00
  c = ( a + b ) / 2.0D+00
  m = 14.0D+00

  call test_glomin_one ( a, b, c, m, machep, e, t, h_03, &
    'h_03(x) = x^3 + x^2' )

  a = -0.5D+00
  b =  +2.0D+00
  c = ( a + b ) / 2.0D+00
  m = 28.0D+00

  call test_glomin_one ( a, b, c, m, machep, e, t, h_03, &
    'h_03(x) = x^3 + x^2' )

  a = -10.0D+00
  b = +10.0D+00
  c = ( a + b ) / 2.0D+00
  m = 72.0D+00

  call test_glomin_one ( a, b, c, m, machep, e, t, h_04, &
    'h_04(x) = ( x + sin(x) ) * exp(-x*x)' )

  a = -10.0D+00
  b = +10.0D+00
  c = ( a + b ) / 2.0D+00
  m = 72.0D+00

  call test_glomin_one ( a, b, c, m, machep, e, t, h_05, &
    'h_05(x) = ( x - sin(x) ) * exp(-x*x)' )

  return
end
subroutine test_zero_one ( a, b, machep, t, f, title )

!*****************************************************************************80
!
!! TEST_ZERO_ONE tests Brent's zero finding routine on one test function.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the two endpoints of the change of sign
!    interval.
!
!    Input, real ( kind = 8 ) MACHEP, an estimate for the relative machine
!    precision.
!
!    Input, real ( kind = 8 ) T, a positive error tolerance.
!
!    Input, external real ( kind = 8 ) F, the name of a user-supplied
!    function, of the form "FUNCTION F ( X )", which evaluates the
!    function whose zero is being sought.
!
!    Input, character ( LEN = * ) TITLE, a title for the problem.
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ), external :: f
  real ( kind = 8 ) fa
  real ( kind = 8 ) fb
  real ( kind = 8 ) fz
  real ( kind = 8 ) machep
  real ( kind = 8 ) t
  character ( len = *  ) title
  real ( kind = 8 ) z
  real ( kind = 8 ) zero
  
  z = zero ( a, b, machep, t, f )
  fz = f ( z )
  fa = f ( a )
  fb = f ( b )

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) trim ( title )
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) '      A                 Z             B'
  write ( *, '(a)' ) '    F(A)              F(Z)          F(B)'
  write ( *, '(a)' ) ' '
  write ( *, '(2x,f14.8,2x,f14.8,2x,f14.8)' ) a,  z,  b
  write ( *, '(2x,g14.6,2x,g14.6,2x,g14.6)' ) fa, fz, fb

  return
end
subroutine test_zero_rc_one ( a, b, machep, t, f, title )

!*****************************************************************************80
!
!! TEST_ZERO_RC_ONE tests Brent's zero finding routine on one test function.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    14 October 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the two endpoints of the change of sign
!    interval.
!
!    Input, real ( kind = 8 ) MACHEP, an estimate for the relative machine
!    precision.
!
!    Input, real ( kind = 8 ) T, a positive error tolerance.
!
!    Input, external real ( kind = 8 ) F, the name of a user-supplied
!    function, of the form "FUNCTION F ( X )", which evaluates the
!    function whose zero is being sought.
!
!    Input, character ( LEN = * ) TITLE, a title for the problem.
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) arg
  real ( kind = 8 ) b
  real ( kind = 8 ), external :: f
  real ( kind = 8 ) machep
  integer ( kind = 4 ) status
  real ( kind = 8 ) t
  character ( len = *  ) title
  real ( kind = 8 ) value
  
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) trim ( title )
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) '    STATUS      X               F(X)'
  write ( *, '(a)' ) ' '

  status = 0

  do 

    call zero_rc ( a, b, t, arg, status, value )

    if ( status < 0 ) then
      write ( *, '(a)' ) ' '
      write ( *, '(a)' ) '  ZERO_RC returned an error flag!'
      exit
    end if

    value = f ( arg )

    write ( *, '(2x,i8,2x,g14.8,2x,g14.8)' ) status, arg, value

    if ( status == 0 ) then
      exit 
    end if

  end do

  return
end
subroutine test_local_min_one ( a, b, eps, t, f, title )

!*****************************************************************************80
!
!! TEST_LOCAL_MIN_ONE tests Brent's local minimizer on one test function.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the endpoints of the interval.
!
!    Input, real ( kind = 8 ) EPS, a positive relative error tolerance.
!
!    Input, real ( kind = 8 ) T, a positive absolute error tolerance.
!
!    Input, external real ( kind = 8 ) F, the name of a user-supplied
!    function, of the form "FUNCTION F ( X )", which evaluates the
!    function whose local minimum is being sought.
!
!    Input, character ( LEN = * ) TITLE, a title for the problem.
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ) eps
  real ( kind = 8 ), external :: f
  real ( kind = 8 ) fa
  real ( kind = 8 ) fb
  real ( kind = 8 ) fx
  real ( kind = 8 ) local_min
  real ( kind = 8 ) t
  character ( len = * ) title
  real ( kind = 8 ) x

  fx = local_min ( a, b, eps, t, f, x )
  fa = f ( a )
  fb = f ( b )

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) trim ( title )
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) '      A                 X             B'
  write ( *, '(a)' ) '    F(A)              F(X)          F(B)'
  write ( *, '(a)' ) ' '
  write ( *, '(2x,f14.8,2x,f14.8,2x,f14.8)' ) a,  x,  b
  write ( *, '(2x,g14.6,2x,g14.6,2x,g14.6)' ) fa, fx, fb

  return
end
subroutine test_local_min_rc_one ( a, b, t, f, title )

!*****************************************************************************80
!
!! TEST_LOCAL_MIN_RC_ONE tests LOCAL_MIN_RC on one test function.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    13 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the endpoints of the interval.
!
!    Input, real ( kind = 8 ) T, a positive absolute error tolerance.
!
!    Input, external real ( kind = 8 ) F, the name of a user-supplied
!    function, of the form "FUNCTION F ( X )", which evaluates the
!    function whose local minimum is being sought.
!
!    Input, character ( LEN = * ) TITLE, a title for the problem.
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) a2
  real ( kind = 8 ) arg
  real ( kind = 8 ) b
  real ( kind = 8 ) b2
  real ( kind = 8 ), external :: f
  integer ( kind = 4 ) status
  integer ( kind = 4 ) step
  real ( kind = 8 ) t
  character ( len = * ) title
  real ( kind = 8 ) value

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) trim ( title )
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) '  Step      X                          F(X)'
  write ( *, '(a)' ) ' '
  step = 0

  arg = a
  value = f ( arg )
  write ( *, '(2x,i4,2x,g24.16,2x,g24.16)' ) step, arg, value

  arg = b
  value = f ( arg )
  write ( *, '(2x,i4,2x,g24.16,2x,g24.16)' ) step, arg, value

  a2 = a
  b2 = b
  status = 0

  do

    call local_min_rc ( a2, b2, arg, status, value )
 
    if ( status < 0 ) then
      write ( *, '(a)' ) ' '
      write ( *, '(a)' ) 'TEST_LOCAL_MIN_RC_ONE - Fatal error!'
      write ( *, '(a)' ) '  LOCAL_MIN_RC returned negative status.'
      exit
    end if

    value = f ( arg )

    step = step + 1
    write ( *, '(2x,i4,2x,g24.16,2x,g24.16)' ) step, arg, value

    if ( status == 0 ) then
      exit
    end if 

  end do

  return
end
subroutine test_glomin_one ( a, b, c, m, machep, e, t, f, title )

!*****************************************************************************80
!
!! TEST_GLOMIN_ONE tests the Brent global minimizer on one test function.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) A, B, the endpoints of the interval.
!
!    Input, real ( kind = 8 ) C, an initial guess for the global
!    minimizer.  If no good guess is known, C = A or B is acceptable.
!
!    Input, real ( kind = 8 ) M, the bound on the second derivative.
!
!    Input, real ( kind = 8 ) MACHEP, an estimate for the relative machine
!    precision.
!
!    Input, real ( kind = 8 ) E, a positive tolerance, a bound for the
!    absolute error in the evaluation of F(X) for any X in [A,B].
!
!    Input, real ( kind = 8 ) T, a positive absolute error tolerance.
!
!    Input, external real ( kind = 8 ) F, the name of a user-supplied
!    function, of the form "FUNCTION F ( X )", which evaluates the
!    function whose global minimum is being sought.
!
!    Input, character ( len = * ) TITLE, a title for the problem.
!
  implicit none

  real ( kind = 8 ) a
  real ( kind = 8 ) b
  real ( kind = 8 ) c
  real ( kind = 8 ) e
  real ( kind = 8 ), external :: f
  real ( kind = 8 ) fa
  real ( kind = 8 ) fb
  real ( kind = 8 ) fx
  real ( kind = 8 ) glomin
  real ( kind = 8 ) m
  real ( kind = 8 ) machep
  real ( kind = 8 ) t
  character ( len = * ) title
  real ( kind = 8 ) x

  fx = glomin ( a, b, c, m, machep, e, t, f, x )
  fa = f ( a )
  fb = f ( b )

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) trim ( title )
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) '      A                 X             B'
  write ( *, '(a)' ) '    F(A)              F(X)          F(B)'
  write ( *, '(a)' ) ' '
  write ( *, '(2x,f14.8,2x,f14.8,2x,f14.8)' ) a,  x,  b
  write ( *, '(2x,g14.6,2x,g14.6,2x,g14.6)' ) fa, fx, fb

  return
end
function f_01 ( x )

!*****************************************************************************80
!
!! F_01 evaluates sin ( x ) - x / 2.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    07 March 1999
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) F_01, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) f_01
  real ( kind = 8 ) x

  f_01 = sin ( x ) - 0.5D+00 * x

  return
end
function f_02 ( x )

!*****************************************************************************80
!
!! F_02 evaluates 2*x-exp(-x).
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    07 March 1999
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) F_02, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) f_02
  real ( kind = 8 ) x

  f_02 = 2.0D+00 * x - exp ( - x )

  return
end
function f_03 ( x )

!*****************************************************************************80
!
!! F_03 evaluates x*exp(-x).
!
!  Modified:
!
!    07 March 1999
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) F_03, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) f_03
  real ( kind = 8 ) x

  f_03 = x * exp ( - x )

  return
end
function f_04 ( x )

!*****************************************************************************80
!
!! F_04 evaluates exp(x) - 1 / (100*x*x).
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    07 March 1999
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) F_04, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) f_04
  real ( kind = 8 ) x

  f_04 = exp ( x ) - 1.0D+00 / 100.0D+00 / x / x

  return
end
function f_05 ( x )

!*****************************************************************************80
!
!! F_05 evaluates (x+3)*(x-1)*(x-1).
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    07 March 1999
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) F_05, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) f_05
  real ( kind = 8 ) x

  f_05 = ( x + 3.0D+00 ) * ( x - 1.0D+00 ) * ( x - 1.0D+00 )

  return
end
function g_01 ( x )

!*****************************************************************************80
!
!! G_01 evaluates (x-2)^2 + 1.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) G_01, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) g_01
  real ( kind = 8 ) x

  g_01 = ( x - 2.0D+00 ) * ( x - 2.0D+00 ) + 1.0D+00

  return
end
function g_02 ( x )

!*****************************************************************************80
!
!! G_02 evaluates x^2 + exp ( - x ).
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) G_02, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) g_02
  real ( kind = 8 ) x

  g_02 = x * x + exp ( - x )

  return
end
function g_03 ( x )

!*****************************************************************************80
!
!! G_03 evaluates x^4+2x^2+x+3.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) G_03, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) g_03
  real ( kind = 8 ) x

  g_03 = ( ( x * x + 2.0D+00 ) * x + 1.0D+00 ) * x + 3.0D+00

  return
end
function g_04 ( x )

!*****************************************************************************80
!
!! G_04 evaluates exp(x)+1/(100X)
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) G_04, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) g_04
  real ( kind = 8 ) x

  g_04 = exp ( x ) + 0.01D+00 / x

  return
end
function g_05 ( x )

!*****************************************************************************80
!
!! G_05 evaluates exp(x) - 2x + 1/(100x) - 1/(1000000x^2)
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) G_05, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) g_05
  real ( kind = 8 ) x

  g_05 = exp ( x ) - 2.0D+00 * x + 0.01D+00 / x - 0.000001D+00 / x / x

  return
end
function h_01 ( x )

!*****************************************************************************80
!
!! H_01 evaluates 2 - x.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) H_01, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) h_01
  real ( kind = 8 ) x

  h_01 = 2.0D+00 - x

  return
end
function h_02 ( x )

!*****************************************************************************80
!
!! H_02 evaluates x^2.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) H_02, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) h_02
  real ( kind = 8 ) x

  h_02 = x * x

  return
end
function h_03 ( x )

!*****************************************************************************80
!
!! H_03 evaluates x^3+x^2.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) H_03, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) h_03
  real ( kind = 8 ) x

  h_03 = x * x * ( x + 1.0D+00 )

  return
end
function h_04 ( x )

!*****************************************************************************80
!
!! H_04 evaluates ( x + sin ( x ) ) * exp ( - x * x ).
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) H_04, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) h_04
  real ( kind = 8 ) x

  h_04 = ( x + sin ( x ) ) * exp ( - x * x )

  return
end
function h_05 ( x )

!*****************************************************************************80
!
!! H_05 evaluates ( x - sin ( x ) ) * exp ( - x * x ).
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license. 
!
!  Modified:
!
!    12 April 2008
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the point at which F is to be evaluated.
!
!    Output, real ( kind = 8 ) H_05, the value of the function at X.
!
  implicit none

  real ( kind = 8 ) h_05
  real ( kind = 8 ) x

  h_05 = ( x - sin ( x ) ) * exp ( - x * x )

  return
end
ian@ian:~/brent$ 

